"use strict";
;
(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['./load-image', './load-image-meta'], factory);
    }
    else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'), require('./load-image-meta'));
    }
    else {
        factory(window.loadImage);
    }
})(function (loadImage) {
    'use strict';
    loadImage.IptcMap = function () {
        return this;
    };
    loadImage.IptcMap.prototype.map = {
        ObjectName: 0x5
    };
    loadImage.IptcMap.prototype.get = function (id) {
        return this[id] || this[this.map[id]];
    };
    loadImage.parseIptcTags = function (dataView, startOffset, sectionLength, data) {
        function getStringFromDB(buffer, start, length) {
            var outstr = '';
            for (var n = start; n < start + length; n++) {
                outstr += String.fromCharCode(buffer.getUint8(n));
            }
            return outstr;
        }
        var fieldValue, dataSize, segmentType;
        var segmentStartPos = startOffset;
        while (segmentStartPos < startOffset + sectionLength) {
            if (dataView.getUint8(segmentStartPos) === 0x1c &&
                dataView.getUint8(segmentStartPos + 1) === 0x02) {
                segmentType = dataView.getUint8(segmentStartPos + 2);
                if (segmentType in data.iptc.tags) {
                    dataSize = dataView.getInt16(segmentStartPos + 3);
                    fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize);
                    if (Object.prototype.hasOwnProperty.call(data.iptc, segmentType)) {
                        if (data.iptc[segmentType] instanceof Array) {
                            data.iptc[segmentType].push(fieldValue);
                        }
                        else {
                            data.iptc[segmentType] = [data.iptc[segmentType], fieldValue];
                        }
                    }
                    else {
                        data.iptc[segmentType] = fieldValue;
                    }
                }
            }
            segmentStartPos++;
        }
    };
    loadImage.parseIptcData = function (dataView, offset, length, data, options) {
        if (options.disableIptc) {
            return;
        }
        var markerLength = offset + length;
        var isFieldSegmentStart = function (dataView, offset) {
            return (dataView.getUint32(offset) === 0x3842494d &&
                dataView.getUint16(offset + 4) === 0x0404);
        };
        while (offset + 8 < markerLength) {
            if (isFieldSegmentStart(dataView, offset)) {
                var nameHeaderLength = dataView.getUint8(offset + 7);
                if (nameHeaderLength % 2 !== 0)
                    nameHeaderLength += 1;
                if (nameHeaderLength === 0) {
                    nameHeaderLength = 4;
                }
                var startOffset = offset + 8 + nameHeaderLength;
                if (startOffset > markerLength) {
                    console.log('Invalid IPTC data: Invalid segment offset.');
                    break;
                }
                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);
                if (offset + sectionLength > markerLength) {
                    console.log('Invalid IPTC data: Invalid segment size.');
                    break;
                }
                data.iptc = new loadImage.IptcMap();
                return loadImage.parseIptcTags(dataView, startOffset, sectionLength, data);
            }
            offset++;
        }
        console.log('No IPTC data at this offset - could be XMP');
    };
    loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData);
});
