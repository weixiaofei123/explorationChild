var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx, css } from "@emotion/core";
import { useRef, useEffect, useState } from "react";
import { style } from "./AutoGridStyle";
import { splitValue } from "@clxx/base";
import { useWindowResize } from "@clxx/effect";
export function AutoGrid(props) {
    let { gap = 0, col = 1, autoHeight = false, children } = props, attrributes = __rest(props, ["gap", "col", "autoHeight", "children"]);
    if (col < 1 || typeof col !== "number") {
        col = 1;
    }
    const container = useRef(null);
    const [list, setList] = useState([]);
    const [size, setSize] = useState(undefined);
    const computeSize = () => {
        const rect = container.current.getBoundingClientRect();
        const { num, unit } = splitValue(gap);
        const itemWidth = (rect.width - (col - 1) * num) / col;
        let itemHeight = undefined;
        if (!autoHeight) {
            itemHeight = itemWidth + unit;
        }
        setSize(css({ width: itemWidth + unit, height: itemHeight }));
    };
    useEffect(computeSize, [children, gap, col]);
    useWindowResize(computeSize);
    useEffect(() => {
        if (!children) {
            return;
        }
        const list = [];
        const pushList = (arr) => {
            arr.forEach(item => {
                if (!item) {
                    return;
                }
                if (Array.isArray(item)) {
                    pushList(item);
                    return;
                }
                if (list.length === 0) {
                    list.push([item]);
                }
                else {
                    const tail = list[list.length - 1];
                    if (tail.length < col) {
                        tail.push(item);
                    }
                    else {
                        list.push([item]);
                    }
                }
            });
        };
        if (Array.isArray(children)) {
            pushList(children);
        }
        else {
            pushList([children]);
        }
        setList(list);
    }, [children, col]);
    const showRows = () => {
        return list.map((row, index) => {
            const rowStlyle = [style.row];
            if (index < list.length - 1) {
                rowStlyle.push(css({
                    marginBottom: gap
                }));
            }
            return (jsx("div", { key: index, css: rowStlyle }, row.map((item, colIndex) => {
                const margin = {
                    marginRight: gap
                };
                if (colIndex === col - 1) {
                    margin.marginRight = 0;
                }
                const colStyle = [
                    style.col,
                    size,
                    css(margin)
                ];
                return (jsx("div", { key: colIndex, css: colStyle }, item));
            })));
        });
    };
    return (jsx("div", Object.assign({ ref: container }, attrributes), showRows()));
}
